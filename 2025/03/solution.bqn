BankMax â† {
    ds	â†	ğ•© - '0'    # digits
	suf â†	Â¯2âŠ¸â†“ â†“ ds  # suffixes of d longer than 2
	                   # (can't really do shit with the shorter ones)
	âŒˆÂ´ âŒˆÂ´Â¨ (âŠ‘âˆ˜Ã—âŸœ10 + 1âŠ¸â†“)Â¨ suf
}

# test
# BankMax "987654321111111"

Sol1 â† {
	 banks â† â€¢FLines ğ•©
	 +Â´ BankMaxÂ¨ banks
}

Sol1 "toyinput"
Sol1 "input"

# (graveyard.bqn went here)

# ok reject everything, this doesn't work, new idea
# one digit at a time
# for 12th, the most significant digit
# take biggest digit with at least 12 spaces to its left

# split that digit off, take the suffix from that digit onwards
# n-- shit you got left, new iteration
# accumulate
# ez

# is it unidiomatic as all hell... yes, most likey
# could have used a âŸ12 or some shit

# digit of max solution
# mildly lispy approach
Digs â† {
0ğ•Šds: âŸ¨âŸ© ;
leftğ•Šds:
    sds â†	dsâ†“Ëœ1-left       # digits you could start with
    md	â†	âŒˆÂ´ sds           # biggest one among these
	im	â†	ds âŠ‘âˆ˜âŠ’ md        # index of max
	md âˆ¾ (left-1)ğ•Š(dsâ†“Ëœ1+im)
}

Bank12 â† {
    ds â† '0' -Ëœ ğ•©
    digs â† 12 Digs ds

	# for non commutative operations
	# please remember that bqn's fold is a right fold
	# given how it's equivalent to putting the op between every element
	# and that bqn functions apply from right to left
	# the fold "starts" from the right/end of the array, and goes to the start

	# so I reversed the digits first
	# then made a train that turns digits into that number backwards
	# because I'm too used to left folds :|
    (10âŠ¸Ã—âˆ˜âŠ¢ + âŠ£)Â´ âŒ½ digs
}

Sol2 â† {+Â´ Bank12Â¨ â€¢Flines ğ•©}

Sol2 "toyinput"
Sol2 "input"

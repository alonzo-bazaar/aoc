Pad â† {
    ğ•Šğ•© :(-â‰ +1Ë™)âŠ¸â†‘ (â‰ +1Ë™)âŠ¸â†‘ ğ•© ; 
    ğ•Šâ¼ğ•©:(-â‰ -1Ë™)âŠ¸â†‘ (â‰ -1Ë™)âŠ¸â†‘ ğ•©
}

# back to the valid regex ig
Sol1 â† {
  +Ë 4â‰¥ +Â´Ë˜ '@'= ('@'âŠ¸=âˆ˜(4âŠ¸âŠ‘))Ë˜âŠ¸/ âˆ˜â€¿9 â¥Š 3â€¿3 â†• Pad PadË˜ > â€¢FLines ğ•©
}

Sol1 "toyinput"
Sol1 "input"

# let's see if greedy works
# at every step, remove all possible rolls
# stop when all rolls are off
# given a floor plan return bitmap of which rolls on that floor are accessible
Accessible â† { ğ•Šfloor:
	s â† â‰¢ floor
	s â¥Š ({4â‰¥+Â´'@'=ğ•©}âˆ§{'@'=4âŠ‘ğ•©})Ë˜ âˆ˜â€¿9â¥Š 3â€¿3â†• PadË˜ Pad floor
}

# I'm gonna be honest, I only have a sliiigt clue as to wat
RemoveAcc â† {âŠ£â—¶âŸ¨âŠ¢,'.'Ë™âŸ©Â´â‰1 â‰ AccessibleâŠ¸â‰ ğ•©}

# this is also gonna look very... iterative
Sol2 â† {
accumğ•Šfloor:
	 access â† Accessible floor 
	 accn â† +Â´+Ë access
	 # it appears I do not know how to use pick
	 # this is far more brutal, but works
	 ğ•¤ {ğ•¨ğ•Š0:accum; ğ•¨ğ•Šğ•©: (accum+ğ•©)ğ•(RemoveAcc floor)} accn
}

0 Sol2 > â€¢Flines "toyinput"
0 Sol2 > â€¢Flines "input"

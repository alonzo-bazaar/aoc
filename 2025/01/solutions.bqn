# idea, get the array of all positions reached by the dial
# without any modulo
# solution 1: when does it become 0 mod 100? (then +Â´ the mask)
# solution 2: when does the floor change Ã·100? (then +Â´ â‰ (something) the resulting array)
# (solution 2 was one hell of a red herring, found a better way)

ReadInt â† (+Â´(10âŠ¸â‹†âˆ˜âŒ½âˆ˜â†•â‰ )âŠ¸Ã—)âˆ˜(-âŸœ'0')
ZeroStops â† {+Â´0=100| ğ•©}

# wentover
# given two integers
# how many integer multiple of 100 are between the two numbers?
# not counting the extremes
# I understand this function kinda sucks ass to look at, sorry
WentOver â† {0=ğ•¨=ğ•©}â—¶âŸ¨0, (âŒŠ{1 + (âŒŠ100Ã·Ëœğ•©-1) - (âŒˆ100Ã·Ëœğ•¨+1)}âŒˆ)âŸ©

# given a filename with the problem data
# return assumed positions and the operations used to go between em
FilePositions â† {
    moves â† â€¢file.Lines ğ•©
    
    nums â† ReadIntâˆ˜(1âŠ¸â†“)Â¨moves
    addp â† ('R'âŠ¸=)âˆ˜âŠ‘Â¨moves # p in the lisp sense
    ops â† (1-Ëœ2Ã—addp)Ã—nums
    positions â† 50âˆ¾50+`ops
    # intial position is 50
    # so gotta start from there and apply shit from there

	positions
}

# given positions we went through, returns solution 1 to problem
Sol1_Positions â† ZeroStops

# given positions we went through
# returns solution 2 to problem
Sol2_Positions â† {
    ğ•Š ps:
	wentover â† +Â´ (Â¯1â†“ps) WentOverÂ¨ (1â†“ps)
	wentover + ZeroStops ps
}

Solution â† {
    positions â† FilePositions ğ•©
    
    sol1 â† Sol1_Positions positions
	sol2 â† Sol2_Positions positions
    
    sol1â€¿sol2
}
